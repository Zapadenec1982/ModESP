SharedState - Контракт модуля
Що це і навіщо
Централізоване сховище стану системи. Модулі читають/пишуть дані без знання один про одного.
Ключові концепції
* Key-value сховище: Зберігає пари "ключ-значення" типу sensor.temp = 25.5
* Type-safe: Підтримує тільки int, float, bool, string. Перевірка типів при компіляції.
* Thread-safe: Захищено м'ютексом. Можна викликати з будь-якої task (крім ISR).
* Підписка на зміни: Модулі отримують callback при зміні значення.
* No allocation: Фіксований розмір сховища. Вся пам'ять виділена при старті.
Архітектура
* ┌─────────────────────────────────────────────────────┐
* │                  SharedState                                                                                                           │
* ├─────────────────────────────────────────────────────┤
* │                                                                                                                                                   │
* │  Storage (compile-time configurable, default 64):                                                           │
* │  ┌─────────────┬─────────────┬─────────────┐                         │
* │  │ Key (32B)                  │ Value (16B)               │ Meta (8B)                  │                         │
* │  └─────────────┴─────────────┴─────────────┘                         │
* │                                                                                                                                                  │
* │  FreeRTOS Mutex → Захист доступу                                                                                 │
* │                                                                                                                                                  │
* │  Subscription Manager:                                                                                                        │
* │  - Ключ → Список callbacks                                                                                               │
* │  - Handle → Ключ (для відписки)                                                                                      │
* │                                                                                                                                                   │
* │  При set():                                                                                                                               │
* │  1. Lock mutex                                                                                                                         │
* │  2. Оновити значення                                                                                                          │
* │  3. Скопіювати список callbacks                                                                                        │
* │  4. Unlock mutex                                                                                                                     │
* │  5. Викликати callbacks (поза mutex!)                                                                               │
* └─────────────────────────────────────────────────────┘
* 

Критичні обмеження
* Конфігурований розмір: Максимальна кількість записів є фіксованою на час роботи для надійності, але може бути налаштована на етапі компіляції (за замовчуванням 64). Це дозволяє адаптувати систему під різні конфігурації обладнання.
* Ключ до 32 символів - довші обрізаються.
* String до 128 символів - довші обрізаються.
* Callbacks синхронні - блокують інші callbacks.
* НЕ викликати з ISR - використовувати чергу.
Naming Convention для ключів
* module.category.property - модуль володіє даними
* system.state.property - системні стани
* runtime.module.setting - конфігурація, що використовується в реальному часі
* status.component.metric - метрики компонентів
* computed.name - обчислені значення
Callback модель
* Виклик одразу після set() - не асинхронно!
* Поза mutex - можна викликати SharedState в callback
* В тому ж потоці - хто викликав set()
* Порядок не гарантований - між різними callbacks
* Exception safe - падіння одного не впливає на інші
Типові сценарії використання
* Конфігурація: Модулі читають runtime.* налаштування з SharedState.
* Обмін даними: Датчик пише sensor.temp.zone1. Контролер читає всі sensor.temp.*.
* Стан системи: Компоненти пишуть status.compressor.running. Monitoring підписаний на status.*.
* Обчислені значення: Модуль А пише raw дані. Модуль Б обчислює та пише похідні.
Взаємодія з Core
* SharedState → EventBus:
   * SharedState НЕ генерує події автоматично.
   * Модуль сам вирішує коли публікувати подію після зміни стану.
   * Чому: не всі зміни стану потребують негайного сповіщення.
* Config → SharedState:
   * Чітке розділення: Config Manager відповідає за персистентні налаштування (зберігаються в NVS). SharedState містить оперативний стан системи (зберігається в RAM).
   * Патерн ініціалізації: На етапі завантаження системи Application або UIManager читає необхідні налаштування з Config Manager і копіює їх в SharedState для ініціалізації оперативного стану (наприклад, Config::get("climate.setpoint") → SharedState::set("runtime.setpoint", ...)).
   * Патерн роботи: Протягом роботи модулі читають оперативні налаштування виключно з SharedState.
* Modules → SharedState:
   * Читання в update() без обмежень.
   * Запис, коли потрібно оновити поточний стан.
   * Підписка в initialize(), відписка в shutdown().
Антипатерни (що НЕ робити)
* Циклічні залежності: A змінює B, B змінює A = нескінченний цикл.
* Важка робота в callback: Блокує всі інші callbacks.
* Високочастотні оновлення: >100Hz краще через EventBus.
* Великі дані: SharedState не для блобів, максимум 128 байт.
* Динамічні ключі: Створення нових ключів runtime = фрагментація.
Атомарні операції
* compare_and_swap: Оновити тільки якщо значення не змінилось.
* increment/decrement: Атомарне збільшення лічильників.
* Використовувати для: лічильників, флагів, критичних оновлень.
Діагностика
* Ключові метрики:
   * Кількість записів (та її максимум)
   * Кількість підписок на ключ
   * Частота оновлень ключа
   * Час виконання callbacks
* Типові проблеми:
   * Переповнення сховища - збільшити розмір при компіляції або оптимізувати використання.
   * Повільні callbacks - винести важку роботу.
   * Type mismatch - перевіряти тип при читанні.
Межі відповідальності
SharedState відповідає за:
* Зберігання оперативних key-value пар (стану).
* Thread-safe доступ.
* Виклик callbacks при зміні стану.
* Збереження типів.
SharedState НЕ відповідає за:
* Валідацію даних.
* Персистентність (це робить Config Manager).
* Генерацію подій (це робить модуль).
* Складну бізнес-логіку.
*