HAL - Довідник (оновлена версія)
Що це і навіщо
Hardware Abstraction Layer (HAL) — це низькорівневий програмний шар, який виступає в ролі "фабрики драйверів" та єдиної точки доступу до фізичних ресурсів мікроконтролера.
Його головна мета — повністю ізолювати решту системи від апаратних деталей. HAL оперує логічними ідентифікаторами ресурсів (hal_id, наприклад, "RELAY_1", "ONEWIRE_BUS_1") і надає готовий до використання функціонал для роботи з ними.
Основні принципи
* Абстракція: HAL ховає деталі роботи з драйверами ESP-IDF, протоколами (I2C, 1-Wire, SPI) та конфігурацією GPIO.
* Ізоляція: Лише спеціалізовані HAL-модулі (SensorModule, RelayModule) мають право спілкуватися з HAL. Модулі бізнес-логіки (ClimateControl) ніколи не звертаються до HAL напряму.
* Конфігурація через BoardConfig.h: HAL зіставляє логічні hal_id з конкретними фізичними пінами, визначеними у файлі board_config.h. Це дозволяє легко адаптувати прошивку під різні апаратні ревізії.
* "Фабрика драйверів": HAL не просто надає доступ до піна, а створює та повертає повноцінні об'єкти-драйвери для роботи з конкретним пристроєм (наприклад, об'єкт для керування реле або шиною 1-Wire).
Структура та потік взаємодії
HAL є сервісом, який ініціалізується на старті системи і використовується HAL-модулями для отримання доступу до "заліза".
Схема взаємодії:
BoardConfig.h     Config.json
     │                 │
     ▼                 ▼
┌─────────────┐   ┌────────────────┐
│ ModuchillHAL│<──┤  SensorModule  │
│ (Фабрика)   │   │  (HAL-Модуль)  │
└─────────────┘   └────────────────┘
     ▲                 │
     │                 │ (публікує дані)
     │                 ▼
┌─────────────┐   ┌─────────────┐
│Драйвер реле ├───┤ RelayModule   │
│(GPIO)       │   │ (HAL-Модуль)  │
└─────────────┘   └─────────────┘

1. Ініціалізація HAL: При старті системи ModuchillHAL читає board_config.h і створює внутрішню мапу, що пов'язує логічні імена ("RELAY_1") з фізичними пінами (GPIO_NUM_4).
2. Ініціалізація HAL-модулів:
   * SensorModule читає свій конфіг sensors.json.
   * Бачачи запис { "hal_id": "ONEWIRE_BUS_1", ... }, він звертається до HAL: hal.get_onewire_bus("ONEWIRE_BUS_1").
   * HAL знаходить відповідний пін, ініціалізує драйвер шини 1-Wire і повертає SensorModule готовий до роботи об'єкт.
3. Робота: SensorModule використовує отриманий об'єкт для опитування датчиків і публікує дані в SharedState.
Концептуальне API ModuchillHAL
HAL надає методи-фабрики для отримання доступу до ресурсів:
// Отримати об'єкт для керування реле за його логічним ID
// Повертає вказівник на об'єкт, що реалізує інтерфейс IGpioOutput
std::unique_ptr<IGpioOutput> get_gpio_output(const std::string& hal_id);

// Отримати об'єкт для читання цифрового входу
std::unique_ptr<IGpioInput> get_gpio_input(const std::string& hal_id);

// Отримати об'єкт для роботи з шиною 1-Wire
OneWireBus& get_onewire_bus(const std::string& hal_id);

// Отримати об'єкт для роботи з каналом АЦП
AdcChannel& get_adc_channel(const std::string& hal_id);

Межі відповідальності
HAL відповідає за:
* Ініціалізацію фізичних пінів та апаратних інтерфейсів (I2C, SPI, UART).
* Зіставлення логічних hal_id з фізичними ресурсами.
* Надання HAL-модулям готових до використання об'єктів-драйверів.
* Інкапсуляцію низькорівневих викликів ESP-IDF.
HAL НЕ відповідає за:
* Бізнес-логіку застосування апаратури.
* Періодичне опитування датчиків (це робить SensorModule).
* Інтерпретацію команд (це робить RelayModule).
* Знання про те, яка роль у реле "RELAY_1" (компресор чи вентилятор).