# Порівняння використання ресурсів: Runtime vs Compile-time UI

## Runtime генерація (початковий підхід)

### Використання RAM
```
UI Schemas (JSON):        ~20-50 KB
Парсинг JSON:            ~10-15 KB (тимчасово)
HTML генерація:          ~15-20 KB
JS/CSS в пам'яті:        ~10-15 KB
Загалом:                 ~55-100 KB RAM
```

### Використання CPU
- Парсинг JSON схем: ~50-100ms при кожному запиті
- Генерація HTML: ~20-30ms
- Серіалізація відповіді: ~10-20ms
- Загалом: ~80-150ms на запит

### Розмір коду
- JSON парсер: вже є (nlohmann)
- HTML генератор: ~5-10 KB
- Шаблонізатор: ~10-15 KB
- Загалом: ~15-25 KB Flash

## Compile-time генерація (оптимізований підхід)

### Використання RAM
```
Тільки динамічні дані:    ~2-5 KB
Буфер відповіді:         ~1-2 KB (повторно використовується)
Загалом:                 ~3-7 KB RAM
```

### Використання CPU
- Читання з PROGMEM: ~1-2ms
- Збір даних: ~5-10ms
- Серіалізація JSON: ~5-10ms
- Загалом: ~11-22ms на запит

### Розмір Flash
```
HTML/JS/CSS (PROGMEM):   ~20-30 KB
Таблиці маппінгу:        ~2-5 KB
UI обробники:            ~3-5 KB
Загалом:                 ~25-40 KB Flash
```

## Детальне порівняння

| Параметр | Runtime | Compile-time | Покращення |
|----------|---------|--------------|------------|
| **RAM (постійна)** | 55-100 KB | 3-7 KB | **93% економія** |
| **RAM (пікова)** | 100-150 KB | 7-10 KB | **93% економія** |
| **CPU на запит** | 80-150ms | 11-22ms | **85% швидше** |
| **Flash** | 15-25 KB | 25-40 KB | -60% (більше) |
| **Час збірки** | 0 | +2-5 сек | Незначно |

## Практичний приклад

### Система з 10 модулями

#### Runtime підхід:
```cpp
// Кожен модуль зберігає схему
class Module {
    nlohmann::json ui_schema_;  // ~2-5KB на модуль
    
    std::string generate_html() {
        // Парсинг і генерація
        std::string html;
        for (auto& control : ui_schema_["controls"]) {
            html += render_control(control);  // CPU intensive
        }
        return html;  // Ще ~5KB тимчасової пам'яті
    }
};

// 10 модулів = 20-50KB постійної RAM
// Плюс ~50KB при генерації сторінки
```

#### Compile-time підхід:
```cpp
// Все в PROGMEM, RAM не використовується
const char INDEX_HTML[] PROGMEM = "<!DOCTYPE html>...";  // 0 RAM

// Тільки динамічні дані
struct RuntimeData {
    float temperature;
    bool door_open;
    // ~100 bytes на модуль
};

// 10 модулів = ~1KB RAM для даних
```

## Оптимізація для різних сценаріїв

### 1. Мінімальна система (ESP32 з 320KB RAM)
- **Рекомендація**: Compile-time
- **Причина**: Критична економія RAM
- **Результат**: 93% більше вільної RAM для бізнес-логіки

### 2. Система з PSRAM (ESP32 з 4MB PSRAM)
- **Можливо**: Runtime для development
- **Але**: Compile-time для production
- **Причина**: PSRAM повільніша, краще Flash

### 3. Динамічні UI вимоги
- **Гібрид**: Базова структура compile-time
- **Runtime**: Тільки видимість елементів
- **Приклад**:
```cpp
// Compile-time: структура
const UIElement ELEMENTS[] PROGMEM = { /* всі елементи */ };

// Runtime: які показувати
std::bitset<MAX_ELEMENTS> visible_elements;
```

## Додаткові переваги Compile-time

### 1. Безпека
- Немає парсингу користувацьких даних
- Неможливо ін'єктувати HTML/JS
- Валідація на етапі збірки

### 2. Надійність
- Менше коду = менше помилок
- Немає runtime помилок генерації
- Детерміністична поведінка

### 3. Оптимізація доставки
```python
# В генераторі можна:
- Мінімізувати HTML/JS/CSS
- Gzip компресія
- Видалити коментарі
- Об'єднати файли
```

### 4. Версіонування
```cpp
// Автоматичний версійний хеш
const char UI_VERSION[] PROGMEM = "a3f2b1c";  // Git hash при збірці
```

## Висновок

Для ESP32 **compile-time генерація** є оптимальним рішенням:

✅ **93% економія RAM** - критично для embedded
✅ **85% швидше** - краща відгук UI
✅ **Більша надійність** - менше runtime помилок
✅ **Краща безпека** - немає динамічного парсингу
❌ **Трохи більше Flash** - але ESP32 має 4-16MB
❌ **Потребує перекомпіляції** - але UI рідко змінюється

Для development можна використовувати гібрид:
- Debug build: часткова runtime генерація
- Release build: повна compile-time оптимізація