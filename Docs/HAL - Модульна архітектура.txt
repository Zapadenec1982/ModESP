# HAL - Довідник (оновлена версія з модульною архітектурою)

## Що це і навіщо

Hardware Abstraction Layer (HAL) — це низькорівневий програмний шар, який виступає в ролі "фабрики драйверів" та єдиної точки доступу до фізичних ресурсів мікроконтролера.

Його головна мета — повністю ізолювати решту системи від апаратних деталей. HAL оперує логічними ідентифікаторами ресурсів (hal_id, наприклад, "RELAY_1", "ONEWIRE_BUS_1") і надає готовий до використання функціонал для роботи з ними.

## Основні принципи

* **Абстракція**: HAL ховає деталі роботи з драйверами ESP-IDF, протоколами (I2C, 1-Wire, SPI) та конфігурацією GPIO.
* **Ізоляція**: Лише спеціалізовані HAL-модулі (SensorModule, RelayModule) мають право спілкуватися з HAL. Модулі бізнес-логіки (ClimateControl) ніколи не звертаються до HAL напряму.
* **Конфігурація через BoardConfig.h**: HAL зіставляє логічні hal_id з конкретними фізичними пінами, визначеними у файлі board_config.h. Це дозволяє легко адаптувати прошивку під різні апаратні ревізії.
* **"Фабрика драйверів"**: HAL не просто надає доступ до піна, а створює та повертає повноцінні об'єкти-драйвери для роботи з конкретним пристроєм (наприклад, об'єкт для керування реле або шиною 1-Wire).

## Модульна архітектура драйверів

### Повна симетрична архітектура

Система тепер має симетричну архітектуру для датчиків та актуаторів:

```
                              SharedState
                                  ▲ ▼
                    ┌─────────────┴─┴─────────────┐
                    ▼                             ▼
           ┌────────────────┐            ┌────────────────┐
           │  SensorModule  │            │ ActuatorModule │
           │                │            │                │
           └───────┬────────┘            └───────┬────────┘
                   │                             │
                   ▼                             ▼
           ┌────────────────┐            ┌────────────────┐
           │ SensorDrivers  │            │ActuatorDrivers │
           │                │            │                │
           │ • DS18B20      │            │ • RelayDriver  │
           │ • NTC          │            │ • PwmDriver    │
           │ • GpioInput    │            │ • GpioOutput   │
           │ • Pressure     │            │ • StepperDriver│
           └────────────────┘            └────────────────┘
                   │                             │
                   ▼                             ▼
              ┌─────────────────────────────────┐
              │            HAL                   │
              │   (Hardware Abstraction Layer)   │
              └─────────────────────────────────┘
```

### Архітектура SensorModule

SensorModule використовує систему модульних драйверів, де кожен тип датчика є окремим компонентом:

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│     HAL         │────▶│  SensorModule    │────▶│ ISensorDriver   │
│ (надає ресурси) │     │ (керує драйверами)│     │   (інтерфейс)   │
└─────────────────┘     └──────────────────┘     └─────────────────┘
                                                           ▲
                                ┌──────────────────────────┼────────────────┐
                                │                          │                │
                        ┌───────────────┐         ┌────────────────┐  ┌────────────┐
                        │ DS18B20Driver │         │  NTCDriver     │  │ GpioInput  │
                        │ (компонент)   │         │  (компонент)   │  │(компонент) │
                        └───────────────┘         └────────────────┘  └────────────┘
```

### Архітектура ActuatorModule

ActuatorModule використовує ту саму модульну систему для виконавчих механізмів:

```
┌─────────────────┐     ┌──────────────────┐     ┌──────────────────┐
│  SharedState    │────▶│  ActuatorModule  │────▶│ IActuatorDriver  │
│   (команди)     │     │ (керує драйверами)│     │   (інтерфейс)    │
└─────────────────┘     └──────────────────┘     └──────────────────┘
                                                           ▲
                                ┌──────────────────────────┼────────────────┐
                                │                          │                │
                        ┌───────────────┐         ┌────────────────┐  ┌────────────┐
                        │  RelayDriver  │         │   PwmDriver    │  │ GpioOutput │
                        │  (компонент)  │         │  (компонент)   │  │(компонент) │
                        └───────────────┘         └────────────────┘  └────────────┘
```

### Переваги модульної архітектури

1. **Повна модульність**: Кожен драйвер датчика - окремий компонент
2. **Динамічне завантаження**: Драйвери реєструються автоматично
3. **Конфігурація без перекомпіляції**: Вибір типів датчиків через JSON
4. **Самодостатність**: Кожен драйвер містить всю логіку, UI схему, калібрування
5. **Розширюваність**: Додавання нових типів без зміни SensorModule

## Структура та потік взаємодії

```
BoardConfig.h     sensors.json         Kconfig
     │                 │                  │
     ▼                 ▼                  ▼
┌─────────────┐   ┌────────────────┐  ┌──────────────┐
│    HAL      │◀──┤  SensorModule  │──┤Driver Registry│
│ (ресурси)   │   │                │  └──────────────┘
└─────────────┘   └────────────────┘          │
     ▲                 │                      ▼
     │                 │               ┌──────────────┐
┌─────────────┐        │               │ DS18B20      │
│IOneWireBus  │◀───────┴───────────────┤ NTC          │
│IGpioOutput  │                        │ Pressure     │
│IAdcChannel  │                        │ (драйвери)   │
└─────────────┘                        └──────────────┘
```

### Процес ініціалізації

1. **Ініціалізація HAL**: При старті системи HAL читає board_config.h і створює внутрішню мапу ресурсів.

2. **Реєстрація драйверів**: Кожен драйвер датчика автоматично реєструється в DriverRegistry при старті.

3. **Ініціалізація SensorModule**:
   - Читає sensors.json
   - Для кожного датчика створює драйвер через реєстр: `registry.create_driver("DS18B20")`
   - Передає драйверу доступ до HAL та конфігурацію
   - Драйвер сам отримує потрібні ресурси від HAL

4. **Робота**: SensorModule періодично опитує всі драйвери через єдиний інтерфейс ISensorDriver.

## Концептуальне API HAL

HAL надає методи-фабрики для отримання доступу до ресурсів:

```cpp
// Отримати об'єкт для керування реле за його логічним ID
std::unique_ptr<IGpioOutput> get_gpio_output(const std::string& hal_id);

// Отримати об'єкт для читання цифрового входу
std::unique_ptr<IGpioInput> get_gpio_input(const std::string& hal_id);

// Отримати об'єкт для роботи з шиною 1-Wire
IOneWireBus& get_onewire_bus(const std::string& hal_id);

// Отримати об'єкт для роботи з каналом АЦП
IAdcChannel& get_adc_channel(const std::string& hal_id);
```

## Межі відповідальності

### HAL відповідає за:
* Ініціалізацію фізичних пінів та апаратних інтерфейсів (I2C, SPI, UART)
* Зіставлення логічних hal_id з фізичними ресурсами
* Надання HAL-модулям готових до використання об'єктів-драйверів
* Інкапсуляцію низькорівневих викликів ESP-IDF

### HAL НЕ відповідає за:
* Бізнес-логіку застосування апаратури
* Періодичне опитування датчиків (це робить SensorModule)
* Інтерпретацію команд (це робить RelayModule)
* Знання про те, яка роль у реле "RELAY_1" (компресор чи вентилятор)

### Драйвери датчиків відповідають за:
* Всю логіку роботи з конкретним типом датчика
* Обробку сирих даних та калібрування
* Надання UI схеми для налаштувань
* Діагностику та обробку помилок

## Приклад конфігурації

### sensors.json з модульною архітектурою

```json
{
  "sensors": [
    {
      "role": "chamber_temp",
      "type": "DS18B20",              // Тип драйвера (зареєстрований)
      "publish_key": "state.sensor.chamber_temp",
      "config": {                      // Конфігурація передається драйверу
        "hal_id": "ONEWIRE_CHAMBER",  // HAL ресурс
        "address": "28ff640264013c28",
        "resolution": 12,
        "offset": 0.0
      }
    },
    {
      "role": "ambient_temp", 
      "type": "NTC",                   // Інший тип драйвера
      "publish_key": "state.sensor.ambient_temp",
      "config": {
        "hal_id": "ADC_AMBIENT_TEMP",
        "ntc_type": "10K_3950",
        "r_series": 10000
      }
    }
  ]
}
```

### actuators.json з модульною архітектурою

```json
{
  "actuators": [
    {
      "role": "compressor",
      "type": "RELAY",                 // Тип драйвера (зареєстрований)
      "command_key": "command.actuator.compressor",
      "status_key": "state.actuator.compressor",
      "config": {                      // Конфігурація драйвера
        "hal_id": "RELAY_COMPRESSOR",
        "min_off_time_s": 180,
        "min_on_time_s": 60
      }
    },
    {
      "role": "fan_speed",
      "type": "PWM",                   // Інший тип драйвера
      "command_key": "command.actuator.fan_speed",
      "status_key": "state.actuator.fan_speed",
      "config": {
        "gpio_num": 25,
        "frequency": 25000,
        "min_duty_percent": 20,
        "max_duty_percent": 100
      }
    }
  ]
}
```

## Потік даних в системі

1. **Датчики → SharedState**:
   ```
   Sensor → SensorDriver → SensorModule → SharedState
   ```

2. **SharedState → Актуатори**:
   ```
   SharedState → ActuatorModule → ActuatorDriver → Actuator
   ```

3. **Бізнес-логіка**:
   ```
   ClimateControl читає з SharedState (датчики)
                 ↓
   Обробляє логіку
                 ↓
   ClimateControl пише в SharedState (команди)
   ```