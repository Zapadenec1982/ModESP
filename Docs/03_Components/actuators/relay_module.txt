RelayModule - Довідник (оновлена версія)
Що це і навіщо
RelayModule — це спеціалізований HAL-модуль, відповідальний за керування усіма релейними виходами системи. Його головна задача — слухати команди від логічних модулів (через SharedState) і перетворювати їх на фізичні дії — вмикання або вимикання реле.
Він є єдиною точкою відповідальності за керування силовими навантаженнями, повністю ізолюючи бізнес-логіку від апаратного рівня.
Основні принципи
* Керованість через стан: RelayModule працює за принципом "бачу команду — виконую". Він не має власної логіки, а лише реагує на зміни відповідних ключів у SharedState.
* Ізоляція: Модулі бізнес-логіки (напр. ClimateControl) не знають, як фізично керувати реле. Вони лише встановлюють бажаний стан у SharedState (напр. "command.relay.compressor": true).
* Безпека: Модуль може включати в себе базові захисні механізми, такі як мінімальний час простою або роботи для захисту обладнання (наприклад, компресора), що задаються в конфігурації.
* Конфігурація через JSON: Список реле, їхні логічні ролі та апаратні ідентифікатори визначаються у власному файлі конфігурації (relays.json).
Структура та Конфігурація
RelayModule під час ініціалізації читає свою секцію з ConfigManager.
Приклад файлу relays.json:
{
 "relays": [
   {
     "role": "compressor",
     "hal_id": "RELAY_1",
     "command_key": "command.relay.compressor",
     "status_key": "state.relay.compressor",
     "min_off_time_s": 180,
     "min_on_time_s": 120
   },
   {
     "role": "defrost_heater",
     "hal_id": "RELAY_2",
     "command_key": "command.relay.defrost_heater",
     "status_key": "state.relay.defrost_heater"
   },
   {
     "role": "fan",
     "hal_id": "RELAY_3",
     "command_key": "command.relay.fan",
     "status_key": "state.relay.fan"
   }
 ]
}

* relays: Масив об'єктів, що описують кожне реле.
   * role: Логічна роль реле в системі.
   * hal_id: Логічний ідентифікатор ресурсу в HAL. RelayModule буде використовувати цей ID, щоб отримати від ModuchillHAL доступ до фізичного реле.
   * command_key: Ключ в SharedState, зміну якого RelayModule буде слухати, щоб отримати команду.
   * status_key: Ключ в SharedState, за яким RelayModule буде публікувати свій поточний фізичний стан (true/false).
   * min_off_time_s, min_on_time_s: (Опціонально) Захисні параметри для конкретного реле.
Патерн роботи
1. Ініціалізація (init()):
   * Читає свою JSON-конфігурацію.
   * Проходить по масиву relays.
   * Для кожного запису:
      * Звертається до ModuchillHAL з hal_id, щоб отримати об'єкт-драйвер для керування фізичним реле.
      * Створює внутрішню структуру, що зв'язує command_key з отриманим об'єктом реле та його параметрами.
      * Підписується на зміни кожного command_key в SharedState за допомогою SharedState::subscribe().
2. Обробка команд (в callback функції):
   * Коли логічний модуль (ClimateControl) змінює значення ключа command.relay.compressor на true, спрацьовує callback всередині RelayModule.
   * Callback перевіряє захисні таймери (напр., чи пройшов min_off_time_s для компресора).
   * Якщо все гаразд, він викликає відповідний метод драйвера для фізичного ввімкнення реле.
   * Після успішного перемикання, він оновлює ключ стану: SharedState::set(status_key, true).
3. Оновлення (update()):
   * Метод update() для RelayModule може бути мінімалістичним. В основному він потрібен для оновлення внутрішніх таймерів (для захисту від частого перемикання). Основна логіка керування є подієво-орієнтованою і знаходиться в колбеках.
Межі відповідальності
RelayModule відповідає за:
* Керування фізичними реле на основі команд зі SharedState.
* Застосування базових апаратних захистів (мінімальний час роботи/простою).
* Публікацію свого актуального фізичного стану (on/off) назад у SharedState.
RelayModule НЕ відповідає за:
* Прийняття рішень про те, коли вмикати чи вимикати реле (це робить бізнес-логіка, напр. ClimateControl).
* Складну логіку керування (напр., керування ПІД-регулятором).
* Знання про те, для чого використовується реле (для нього це просто вихід з певними захисними таймерами).