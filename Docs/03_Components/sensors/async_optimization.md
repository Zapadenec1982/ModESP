# Оптимізація SensorModule для асинхронних драйверів

## Проблема оригінального підходу

При використанні блокуючих драйверів (як оригінальний DS18B20), SensorModule може блокувати всю систему:

```
SensorModule::update() {
    for (sensor : sensors) {
        sensor->read();  // DS18B20 блокує на 750ms!
    }
}
```

При 4 сенсорах DS18B20 - блокування на 3 секунди!

## Рішення з асинхронними драйверами

### 1. Налаштування інтервалу оновлення

В `system.json`:
```json
{
  "modules": {
    "SensorModule": {
      "enabled": true,
      "update_interval_ms": 100  // Оновлювати кожні 100ms
    }
  }
}
```

Або програмно:
```cpp
ModuleManager::set_update_interval("SensorModule", 100);
```

### 2. Оптимальні інтервали для різних конфігурацій

| Конфігурація | Рекомендований інтервал | Причина |
|--------------|------------------------|---------|
| Тільки NTC | 500-1000ms | NTC читаються швидко |
| DS18B20_Async (9 біт) | 50-100ms | Конверсія 100ms |
| DS18B20_Async (12 біт) | 100-200ms | Конверсія 750ms |
| Змішана конфігурація | 100ms | Універсальний |

### 3. Приклад роботи асинхронного драйвера

```
Цикл 1 (t=0ms):     DS18B20_Async: IDLE → CONVERSION_REQUESTED
Цикл 2 (t=100ms):   DS18B20_Async: WAITING_FOR_CONVERSION (повертає кешоване значення)
Цикл 3 (t=200ms):   DS18B20_Async: WAITING_FOR_CONVERSION (повертає кешоване значення)
...
Цикл 8 (t=800ms):   DS18B20_Async: READY_TO_READ → IDLE (нове значення)
```

### 4. Переваги підходу

1. **Не блокує систему** - кожен виклик read() повертається за 1-5ms
2. **Завжди є дані** - повертає кешоване значення під час конверсії
3. **Паралельна робота** - всі сенсори на одній шині конвертують одночасно
4. **Економія CPU** - оновлення раз в 100ms замість кожного циклу

### 5. Моніторинг продуктивності

Використовуйте діагностику для перевірки:

```cpp
auto diagnostics = sensor_module->get_diagnostics();
for (auto& sensor : diagnostics["sensors"]) {
    ESP_LOGI(TAG, "Sensor %s: state=%s, reads=%d, errors=%d",
        sensor["role"].get<std::string>().c_str(),
        sensor["state"].get<std::string>().c_str(),
        sensor["successful_reads"].get<int>(),
        sensor["error_count"].get<int>()
    );
}
```

### 6. Міграція з блокуючих драйверів

1. Змініть тип в конфігурації: `"DS18B20"` → `"DS18B20_Async"`
2. Додайте `"max_retries": 3`
3. Встановіть `update_interval_ms: 100` для SensorModule
4. Перевірте роботу через діагностику

## Результат

- CPU навантаження: 100% → <1%
- Час відгуку системи: 3000ms → 5ms
- Доступність даних: періодична → постійна
