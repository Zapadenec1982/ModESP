# HAL - Довідник

## Що це і навіщо

Hardware Abstraction Layer (HAL) — це низькорівневий програмний шар, який виступає в ролі "фабрики драйверів" та єдиної точки доступу до фізичних ресурсів мікроконтролера.

Його головна мета — повністю ізолювати решту системи від апаратних деталей. HAL оперує логічними ідентифікаторами ресурсів (hal_id, наприклад, "RELAY_1", "ONEWIRE_BUS_1") і надає готовий до використання функціонал для роботи з ними.

## Основні принципи

- **Абстракція**: HAL ховає деталі роботи з драйверами ESP-IDF, протоколами (I2C, 1-Wire, SPI) та конфігурацією GPIO.
- **Ізоляція**: Лише спеціалізовані HAL-модулі (SensorModule, RelayModule) мають право спілкуватися з HAL. Модулі бізнес-логіки (ClimateControl) ніколи не звертаються до HAL напряму.
- **Конфігурація через BoardConfig.h**: HAL зіставляє логічні hal_id з конкретними фізичними пінами, визначеними у файлі board_config.h. Це дозволяє легко адаптувати прошивку під різні апаратні ревізії.
- **"Фабрика драйверів"**: HAL не просто надає доступ до піна, а створює та повертає повноцінні об'єкти-драйвери для роботи з конкретним пристроєм (наприклад, об'єкт для керування реле або шиною 1-Wire).

## Структура та потік взаємодії

HAL є сервісом, який ініціалізується на старті системи і використовується HAL-модулями для отримання доступу до "заліза".

### Схема взаємодії:

```
BoardConfig.h     Config.json
     │                 │
     ▼                 ▼
┌─────────────┐   ┌────────────────┐
│ ModuchillHAL│<──┤  SensorModule  │
│ (Фабрика)   │   │  (HAL-Модуль)  │
└─────────────┘   └────────────────┘
     ▲                 │
     │                 │ (публікує дані)
     │                 ▼
┌─────────────┐   ┌─────────────┐
│Драйвер реле ├───┤ RelayModule   │
│(GPIO)       │   │ (HAL-Модуль)  │
└─────────────┘   └─────────────┘
```

### Процес роботи:

1. **Ініціалізація HAL**: При старті системи ModuchillHAL читає board_config.h і створює внутрішню мапу, що пов'язує логічні імена ("RELAY_1") з фізичними пінами (GPIO_NUM_4).

2. **Ініціалізація HAL-модулів**:
   - SensorModule читає свій конфіг sensors.json.
   - Бачачи запис `{ "hal_id": "ONEWIRE_BUS_1", ... }`, він звертається до HAL: `hal.get_onewire_bus("ONEWIRE_BUS_1")`.
   - HAL знаходить відповідний пін, ініціалізує драйвер шини 1-Wire і повертає SensorModule готовий до роботи об'єкт.

3. **Робота**: SensorModule використовує отриманий об'єкт для опитування датчиків і публікує дані в SharedState.

## Концептуальне API ModuchillHAL

HAL надає методи-фабрики для отримання доступу до ресурсів:

```cpp
// Отримати об'єкт для керування реле за його логічним ID
// Повертає вказівник на об'єкт, що реалізує інтерфейс IGpioOutput
std::unique_ptr<IGpioOutput> get_gpio_output(const std::string& hal_id);

// Отримати об'єкт для читання цифрового входу
std::unique_ptr<IGpioInput> get_gpio_input(const std::string& hal_id);

// Отримати об'єкт для роботи з шиною 1-Wire
OneWireBus& get_onewire_bus(const std::string& hal_id);

// Отримати об'єкт для роботи з каналом АЦП
AdcChannel& get_adc_channel(const std::string& hal_id);
```

## Межі відповідальності

### HAL відповідає за:
- Ініціалізацію фізичних пінів та апаратних інтерфейсів (I2C, SPI, UART).
- Зіставлення логічних hal_id з фізичними ресурсами.
- Надання HAL-модулям готових до використання об'єктів-драйверів.
- Інкапсуляцію низькорівневих викликів ESP-IDF.

### HAL НЕ відповідає за:
- Бізнес-логіку застосування апаратури.
- Періодичне опитування датчиків (це робить SensorModule).
- Інтерпретацію команд (це робить RelayModule).
- Знання про те, яка роль у реле "RELAY_1" (компресор чи вентилятор).

## Практичні рекомендації

### Використання HAL у модулях

```cpp
// Правильно: HAL-модуль отримує ресурси від HAL
class SensorModule {
private:
    std::unique_ptr<IOneWireBus> onewire_bus;
    
public:
    void initialize(ModuchillHAL& hal) {
        // Отримати шину через HAL
        onewire_bus = hal.get_onewire_bus("ONEWIRE_CHAMBER");
        
        // Використовувати готовий об'єкт
        onewire_bus->scan_devices();
    }
};
```

### Конфігурація board_config.h

```cpp
// Приклад конфігурації плати
#define ONEWIRE_CHAMBER_PIN     GPIO_NUM_4
#define RELAY_COMPRESSOR_PIN    GPIO_NUM_15
#define ADC_AMBIENT_TEMP_PIN    ADC1_CHANNEL_6

// HAL використовує ці дефініції для створення відповідності
// "ONEWIRE_CHAMBER" -> GPIO_NUM_4
// "RELAY_COMPRESSOR" -> GPIO_NUM_15
```

Цей підхід забезпечує повну ізоляцію апаратних деталей та дозволяє легко адаптувати прошивку під різні конфігурації плат. 