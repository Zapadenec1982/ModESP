ConfigManager - Фінальний довідник
Що це і навіщо
ConfigManager — це централізований компонент, що відповідає за управління персистентними (постійними) налаштуваннями системи. Його ключова особливість — робота з модульною конфігурацією, де налаштування для кожного функціонального блоку зберігаються в окремих файлах. Це дозволяє додавати нові модулі в систему, не змінюючи існуючі файли конфігурації.
Основні концепції
* Модульні файли: Налаштування для кожної логічної частини системи (system, climate, sensors) зберігаються в окремих .json файлах.
* Агрегація в пам'яті: Під час завантаження ConfigManager зчитує всі окремі файли конфігурації та об'єднує їх в єдиний JSON-об'єкт в оперативній пам'яті для зручного доступу.
* Зберігання в NVS: Весь об'єднаний об'єкт конфігурації серіалізується і зберігається в один ключ в NVS, що гарантує атомарність та цілісність даних.
* RAM-кеш: Всі операції читання відбуваються з кешу в оперативній пам'яті для максимальної швидкодії.
* Версійність та міграція: Принцип версійності застосовується до всього об'єднаного об'єкта конфігурації.
Архітектура та потік даних
1. Структура файлів: У проекті є директорія з файлами конфігурації: system.json, climate.json, sensors.json і т.д.
2. Завантаження: При старті ConfigManager завантажує конфігурацію з NVS. Якщо її там немає, він агрегує всі вбудовані у прошивку .json файли в єдиний об'єкт.
3. Доступ: Модулі отримують доступ до параметрів через шляхи з крапками, напр. ConfigManager::get("climate.setpoint").
4. Збереження: UIManager ініціює збереження. ConfigManager серіалізує весь об'єднаний об'єкт з RAM і атомарно записує його в NVS.
Життєвий цикл конфігурації
1. Завантаження (Load): На етапі INIT Application ініціює завантаження конфігурації.
2. Валідація (Validate): Завантажені дані перевіряються на коректність.
3. Міграція (Migrate): При невідповідності версій запускаються скрипти міграції.
4. Доступ (Get): Протягом роботи системи модулі читають дані з кешу в RAM.
5. Зміна (Set): UIManager на основі дій користувача викликає set(). ConfigManager оновлює кеш і встановлює прапорець is_dirty = true.
6. Збереження (Save): UIManager викликає save(), і ConfigManager записує кеш в NVS.
Концептуальне API
* get(path): Отримати значення з кешу за шляхом ("climate.setpoint").
* set(path, value): Встановити значення в кеші, позначає конфігурацію як "брудну".
* save(): Зберегти поточний стан кешу в NVS.
* is_dirty(): Повернути true, якщо є незбережені зміни.
* discard_changes(): Скасувати незбережені зміни в кеші.
Взаємодія з іншими компонентами
* Application: Ініціює завантаження конфігурації.
* ModuleManager: Отримує об'єднану конфігурацію і роздає кожному модулю його секцію.
* UIManager: Є основним клієнтом. Відповідає за логіку взаємодії з користувачем, викликає set(), перевіряє is_dirty(), ініціює save() або discard_changes().
* SharedState: ConfigManager відповідає за персистентні налаштування. SharedState — за оперативний стан. На старті налаштування з Config копіюються в SharedState для ініціалізації.
Типові сценарії
* Перший запуск: ConfigManager не знаходить конфігурації в NVS, агрегує всі вбудовані файли, зберігає результат в NVS і продовжує роботу.
* Оновлення прошивки: Нова прошивка очікує версію 3, але в NVS збережена версія 2. ConfigManager запускає мігратор v2_to_v3, оновлює дані в кеші та зберігає нову версію 3 в NVS.
* Зміна уставки: WebServer надсилає команду в UIManager. UIManager викликає Config::set(). При спробі вийти зі сторінки UIManager перевіряє is_dirty() і показує діалог "Зберегти зміни?".
Антипатерни (Що НЕ робити)
* Зберігати при кожній зміні: Часті записи зношують флеш-пам'ять. Зберігайте лише після підтвердження користувачем.
* Зберігати динамічний стан: Поточна температура, стан реле, лічильники — це оперативні дані, місце яких у SharedState.
* Читання з NVS в головному циклі: Це дуже повільно. Всі налаштування мають читатися з RAM-кешу.
* Складна логіка в міграторах: Скрипти міграції мають бути максимально простими (перейменувати поле, додати нове).
Діагностика та Відновлення
* Пошкоджена конфігурація: Якщо при завантаженні JSON виявляється пошкодженим, система має залогувати помилку, завантажити значення за замовчуванням і спробувати перезаписати NVS.
* Помилка міграції: Якщо міграція не вдається, система має перейти в безпечний режим або використати конфігурацію за замовчуванням.
* Ключові метрики: Версія конфігурації, час останнього збереження, прапорець is_dirty.
Межі відповідальності
ConfigManager відповідає за:
* Агрегацію модульних файлів конфігурації.
* Атомарне читання та запис конфігурації в/з NVS.
* Кешування конфігурації в RAM та відстеження "брудного" стану.
* Версійність та запуск механізму міграції.
ConfigManager НЕ відповідає за:
* Прийняття рішень про те, коли зберігати (це робить UIManager).
* Логіку застосування налаштувань (це роблять модулі).
* Зберігання оперативного стану системи (це SharedState).