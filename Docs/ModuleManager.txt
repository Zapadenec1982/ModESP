ModuleManager - Фінальний довідник
Огляд та філософія
Що таке ModuleManager?
ModuleManager — це координатор життєвого циклу модулів для системи ModuChill. Він забезпечує детерміновану ініціалізацію, конфігурування, пріоритетне виконання, моніторинг "здоров'я" та поступову деградацію. Цей компонент гарантує стабільну роботу системи навіть у випадку збою окремих модулів.
Основні обов'язки
* Управління життєвим циклом: Реєстрація → Конфігурування → Ініціалізація → Виконання → Зупинка
* Розповсюдження конфігурації: Доставка відповідної секції конфігурації кожному модулю.
* Пріоритетне планування: 5-рівнева система пріоритетів для детермінованого порядку виконання.
* Моніторинг "здоров'я": Автоматичний розрахунок балів "здоров'я" та обробка деградації.
* Відстеження ресурсів: Використання пам'яті, час виконання та моніторинг дедлайнів.
Архітектурні принципи
* Детерміноване виконання: Фіксований порядок виконання за пріоритетами, передбачуваний таймінг.
* Ізоляція збоїв: Збої в модулях не призводять до падіння всієї системи.
* Нульова динамічна алокація: Вся пам'ять виділяється під час ініціалізації.
* Модель з однією задачею: Всі модулі виконуються кооперативно в одній головній задачі.
Архітектура та потік конфігурації
ModuleManager виступає як центральний дистриб'ютор конфігурацій, які він отримує від ConfigManager.
1. ConfigManager
  (збирає всі .json)
        │
        │ (весь об'єкт config)
        ▼
2. ModuleManager
  (метод configure_all)
        │
        ├─► module->configure(config["climate"]) ───► ClimateControlModule
        │
        ├─► module->configure(config["sensors"]) ───► SensorModule
        │
        └─► module->configure(config["relays"])  ───► RelayModule

Патерн конфігурування модулів:
Щоб процес був автоматизованим, вводиться угода про іменування.
1. Угода про іменування: Розробник нового модуля, наприклад MqttModule, створює для нього файл конфігурації mqtt.json.
2. Агрегація: ConfigManager завантажить цей файл і створить в пам'яті секцію "mqtt": { ... }.
3. Дистрибуція: ModuleManager під час виклику configure_all() побачить модуль з іменем "MqttModule", знайде в загальній конфігурації секцію "mqtt" (ім'я в нижньому регістрі) і передасть її в метод MqttModule::configure().
Життєвий цикл (оновлений)
1. Реєстрація: Всі модулі реєструються в ModuleManager.
2. Завантаження конфігурації: Application викликає ConfigManager::load().
3. КОНФІГУРУВАННЯ: Application викликає ModuleManager::configure_all().
4. Ініціалізація: Application викликає ModuleManager::init_all().
5. Виконання: Application викликає ModuleManager::tick_all() в головному циклі.
6. Зупинка: Application викликає ModuleManager::shutdown_all().
Архітектура модуля
Контракт базового модуля (BaseModule)
Кожен модуль повинен реалізовувати інтерфейс BaseModule:
class BaseModule {
public:
   // Обов'язково: Ідентифікація
   virtual const char* get_name() const = 0;
  
   // Обов'язково: Життєвий цикл
   virtual esp_err_t init() = 0;
   virtual void update() = 0;
   virtual void stop() = 0;
  
   // Опціонально: Конфігурація
   virtual void configure(const nlohmann::json& config) {}
  
   // Опціонально: "Здоров'я"
   virtual bool is_healthy() const { return true; }
  
   // Опціонально: Продуктивність
   virtual uint32_t get_max_update_time_us() const { return 2000; } // 2мс
};

Система пріоритетів
ModuleManager використовує 5-рівневу систему пріоритетів:
* CRITICAL (0) - Безпека та Захист
   * Час виконання: < 100мкс
   * Приклади: ProtectionModule, WatchdogModule
   * Дія при збої: Перезавантаження системи
* HIGH (1) - Введення/виведення в реальному часі
   * Час виконання: < 500мкс
   * Приклади: SensorModule, RelayModule
   * Дія при збої: Режим деградації
* STANDARD (2) - Бізнес-логіка
   * Час виконання: < 2мс
   * Приклади: ClimateControlModule, DefrostModule
   * Дія при збої: Вимкнення функції
* LOW (3) - Інтерфейс користувача та API
   * Час виконання: < 5мс
   * Приклади: WebServerAdapter, DisplayAdapter
   * Дія при збої: Деградація UI
* BACKGROUND (4) - Аналітика
   * Час виконання: < 10мс
   * Приклади: TelemetryModule, LoggerModule
   * Дія при збої: Немає впливу
Модель виконання
Інтеграція з головним циклом
Головний цикл Application (100Гц):
├── ModuleManager::tick_all() [бюджет 8мс]
│   ├── Виконання CRITICAL модулів
│   └── ... (і так далі за пріоритетами)
├── EventBus::process() [бюджет 2мс]
└── Системні задачі [< 1мс]

Повний довідник API (концептуальний)
// Ініціалізувати підсистему
static void init();

// Зареєструвати модуль (володіння передається менеджеру)
static esp_err_t register_module(std::unique_ptr<BaseModule> module, ModulePriority priority);

// Сконфігурувати всі зареєстровані модулі
void configure_all(const nlohmann::json& config);

// Ініціалізувати всі сконфігуровані модулі
static esp_err_t init_all();

// Оновити всі активні модулі
static void tick_all();

// Зупинити всі модулі
static void shutdown_all();

// Знайти модуль за іменем
static BaseModule* get_module(const char* name);

// Увімкнути/вимкнути виконання модуля
static bool enable_module(const char* name);
static bool disable_module(const char* name);

"Здоров'я" та діагностика
Розрахунок балу "здоров'я"
Кожен модуль має бал "здоров'я" (0-100), який розраховується з:
* Базовий бал: 100
* Штраф за помилку: -10 за кожну помилку поспіль
* Штраф за дедлайн: -20, якщо постійно пропускає дедлайни
* Специфічно для модуля: -10, якщо is_healthy() повертає false
Структура звіту про "здоров'я"
struct ModuleHealthReport {
   struct ModuleInfo {
       const char* name;
       ModuleState state;
       uint8_t health_score;
       uint32_t avg_update_time_us;
       uint32_t max_update_time_us;
       uint32_t deadline_misses;
       uint32_t error_count;
   };
  
   size_t total_modules;
   size_t healthy_modules;
   size_t error_modules;
   std::vector<ModuleInfo> modules;
};

Патерни інтеграції
* Комунікація модулів: Використовуйте EventBus для подій та SharedState для стану. Прямі виклики між модулями заборонені.
* Інтеграція UI: UI-адаптери (WebServer) запитують схему в UIManager і передають йому команди, повністю ізолюючи логіку.
Характеристики продуктивності
* Час: Реєстрація < 50мкс, пошук < 10мкс, накладні витрати tick_all < 30мкс.
* Пам'ять: Основні структури ~4KB IRAM, накладні витрати на модуль ~300B IRAM.
* CPU: Координація tick_all < 1%, моніторинг "здоров'я" < 0.5%.
Поширені проблеми та рішення
* Модуль не реєструється: Перевірте порядок реєстрації, унікальність імен.
* Збій ініціалізації: Перевірте конфігурацію, наявність апаратних залежностей.
* Проблеми з продуктивністю: Профілюйте модулі, виносьте важкі операції в окремі задачі.
Зведення найкращих практик
* Дизайн модуля: Принцип єдиної відповідальності, явне впровадження залежностей.
* Життєвий цикл: Швидкий init(), швидкий update() (< 1мс), чистий stop().
* Продуктивність: Уникайте блокуючих операцій, дотримуйтесь часових лімітів.
* Управління пам'яттю: Надавайте перевагу статичному виділенню, використовуйте PSRAM для великих буферів.