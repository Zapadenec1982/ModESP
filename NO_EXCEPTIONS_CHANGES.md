# Зміни у проекті ModESP для відключення C++ винятків

## Виконані зміни:

### 1. Створено новий файл обробки помилок
- **Файл**: `components/core/error_handling.h`
- **Зміст**: 
  - Клас `Result<T>` для повернення результатів з кодами помилок
  - Функція `safe_execute()` для безпечного виконання коду
  - Клас `ErrorCollector` для збору статистики помилок
  - Макроси `MOD_CHECK` та `MOD_CHECK_RETURN`

### 2. Оновлено конфігурацію проекту
- **Файл**: `sdkconfig.defaults`
- **Зміни**: 
  - `CONFIG_COMPILER_CXX_EXCEPTIONS=n` - вимкнено винятки
  - Додано оптимізації для промислового застосування
  - Включена підтримка PSRAM

### 3. Модифіковано файли ядра

#### event_bus.h / event_bus.cpp
- Замінено try-catch блоки на `safe_execute()`
- Додано `ErrorCollector` для відстеження помилок
- Додані функції API:
  - `has_errors()` - перевірка наявності помилок
  - `get_error_count()` - кількість помилок
  - `clear_errors()` - очищення помилок
  - `log_errors()` - виведення всіх помилок у лог

#### shared_state.cpp
- Замінено try-catch блоки на `safe_execute()`
- Додано включення `error_handling.h`

## Переваги:

1. **Економія ресурсів**:
   - Flash: -50-100 КБ
   - SRAM: -16-24 КБ

2. **Покращена продуктивність**:
   - Детермінований час виконання
   - Відсутність overhead від stack unwinding

3. **Краща діагностика**:
   - ErrorCollector зберігає історію помилок
   - Можливість аналізу помилок по контексту

## Рекомендації для подальшої роботи:

1. **Переписати інші модулі**:
   - Використовувати `Result<T>` для функцій що повертають значення
   - Використовувати `esp_err_t` для void функцій

2. **Налаштувати ErrorCollector**:
   - Розмістити в PSRAM для збільшення історії
   - Налаштувати кількість записів під потреби

3. **Моніторинг помилок**:
   - Періодично викликати `log_errors()` 
   - Інтегрувати з системою телеметрії

## Компіляція:
```bash
idf.py fullclean
idf.py build
```

Проект тепер працює без C++ винятків!
